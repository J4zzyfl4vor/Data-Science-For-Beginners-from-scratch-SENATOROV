"""Измерение быстродействия и сложности алгоритмов."""

# ***Модуль timeit***:
#
# «Преждевременная оптимизация — корень всех зол» — популярное изречение в об-
# ласти разработки. (Его часто приписывают знаменитому ученому Дональду Кнуту,
# который отдает его авторство Тони Хоару. В свою очередь Тони Хоар описывает
# ситуацию с точностью до наоборот.) Преждевременная оптимизация (то есть оп-
# тимизация, выполняемая до того, как вы поймете, что же нужно оптимизировать)
# часто проявляется, когда программисты пытаются использовать хитроумные трюки
# для экономии памяти или написания более быстрого кода. Например, один из та-
# ких трюков основан на использовании алгоритма XOR, для того чтобы поменять
# местами два целых значения без использования третьей временной переменной:
# >>> a, b = 42, 101 # Создание двух переменных.
# >>> print(a, b)
# 42 101
# >>> # Серия операций ^ XOR меняет значения местами:
# >>> a = a ^ b
# >>> b = a ^ b
# >>> a = a ^ b
# >>> print(a, b) # Значения поменялись местами.

# Модуль timeit стандартной библиотеки Python способен измерить скорость
# выполнения небольшого фрагмента кода. Для этого его запускают тысячи или
# миллионы раз, после чего вычисляют среднее время выполнения. Модуль timeit
# также временно отключает автоматический сборщик мусора для получения более
# стабильных данных времени выполнения. Если вы хотите вычислить время вы-
# полнения нескольких строк, передайте многострочный текст или разделите строки
# кода символами ;:
# >>> import timeit
# >>> timeit.timeit('a, b = 42, 101; a = a ^ b; b = a ^ b; a = a ^ b')

# На моем компьютере выполнение этого кода с алгоритмом XOR занимает прибли-
# зительно 1/10 секунды. Быстро это или нет? Сравним с кодом, меняющим местами
# два числа с использованием третьей временной переменной:
# >>> import timeit
# >>> timeit.timeit('a, b = 42, 101; temp = a; a = b; b = temp')
# 0.027540389999998638

# Cюрприз! Код с третьей временной переменной не только лучше читается, но
# и работает почти вдвое быстрее! Возможно, трюк с XOR экономит несколько бай-
# тов памяти, но за счет скорости и удобочитаемости кода. Нет смысла жертвовать
# удобочитаемостью ради нескольких байтов памяти или наносекунд выполнения.
# Еще лучше поменять местами две переменные, используя уловку множественного
# присваивания, которая также требует меньше времени:

# >>> timeit.timeit('a, b = 42, 101; a, b = b, a')

# По умолчанию код строки, переданной timeit.timeit(), не может обращаться
# к переменным и функциям в остальном коде программы:
# >>> import timeit
# >>> spam = 'hello' # Определяем переменную spam.
# >>> timeit.timeit('print(spam)', number=1) # Измеряем время выполнения вывода spam.
# Traceback (most recent call last):
# File "<stdin>", line 1, in <module>
# File "C:\Users\Al\AppData\Local\Programs\Python\Python37\lib\timeit.py",
# line 232, in timeit
# return Timer(stmt, setup, timer, globals).timeit(number)

# Чтобы решить эту проблему, передадим функции возвращаемое значение globals()
# в ключевом аргументе globals:
# >>> timeit.timeit('print(spam)', number=1, globals=globals())

# ***Профилировщик cProfile***:
#
# Хотя модуль timeit полезен для хронометража небольших фрагментов кода, модуль
# cProfile более эффективен для анализа целых функций или программ. Процесс
# профилирования систематически анализирует скорость вашей программы, затра-
# ты памяти и другие аспекты. Модуль cProfile — профилировщик Python, то есть
# программа, измеряющая время выполнения программы, а также строящая профиль
# времени выполнения отдельных вызовов функций программы

# Чтобы воспользоваться профилировщиком cProfile, передайте код, для которого
# хотите провести измерения, при вызове cProfile.run(). Следующий пример по-
# казывает, как cProfiler измеряет и выводит время выполнения короткой функции,
# суммирующей все числа от 1 до 1 000 000:
# import time, cProfile
# def addUpNumbers():
# total = 0
# for i in range(1, 1000001):
# total += i
# cProfile.run('addUpNumbers()')

# Каждая строка представляет некоторую функцию и время, требуемое для выпол-
# нения этой функции. ***Столбцы выходных данных cProfile.run():***
#
#     - ncalls — количество вызовов функции;
#     - tottime — общее время, требуемое для выполнения функции, не считая
#         времени в подфункциях;
#     - percall — общее время, разделенное на количество вызовов;
#     - cumtime — накопленное время для выполнения функции и ее подфункций;
#     - percall — общее время, деленное на количество вызовов;
#     
# filename:lineno(function) — файл, в котором определяется функция, и но-
# мер строки.
# Например, загрузите файлы rsaCipher.py и al_sweigart_pubkey.txt на https://
# nostarch.com/crackingcodes/. Программа RSA Cipher была представлена в книге
# Cracking Codes with Python (издательство No Starch Press, 2018)1. Введите сле-
# дующий фрагмент в интерактивной оболочке, чтобы профилировать функцию
# encryptAndWriteToFile(). Эта функция шифрует сообщение из 300 000 символов,
# созданное выражением 'abc' * 100000:

# ***Анализ алгоритмов с использованием нотации***
# «O-большое»
#
# Нотация «О-большое» — метод анализа алгоритмов, описывающий масштабиро-
# вание времени выполнения кода. Код классифицируется по нескольким порядкам
# сложности, каждый из которых в общем виде показывает, насколько увеличится
# время выполнения кода при возрастании объема выполняемой работы

# Алгоритм может выполняться на
# быстром или медленном компьютере, но нотация «O-большое» все равно может
# использоваться для описания быстродействия алгоритма в целом независимо от
# того, на каком оборудовании этот алгоритм выполняется. В нотации «О-большое»
# не используются конкретные единицы для описания времени выполнения ал-
# горитма (секунды, такты процессора и т. д.), потому что эти показатели будут
# изменяться на разных компьютерах или при использовании разных языков про-
# граммирования.

# ***Порядки нотации*** «О-большое»:
#
# Нотация «О-большое» обычно определяет несколько порядков сложности. Ниже
# эти порядки перечислены по возрастанию (сначала указаны низкие порядки, при
# которых код с ростом объема данных замедляется в наименьшей степени, а в кон-
# це — высокие порядки с наибольшим замедлением).
# 1. O(1), постоянное время (самый низкий порядок).
# 2. O(log n), логарифмическое время.
# 3. O(n), линейное время.
# 4. O(n log n), время N-Log-N.
# 5. O(n2), полиномиальное время.
# 6. O(2n), экспоненциальное время.
# 7. O(n!), факториальное время (наивысший порядок).

# Чтобы использовать нотацию «О-большое», не обязательно понимать точный мате-
# матический смысл таких терминов, как «логарифмическое» или «полиномиальное».
# Все порядки я более подробно опишу в следующем разделе, а пока ограничусь
# простым обозначением.
#
#
# O(1) и O(log n) — быстрые алгоритмы.
# O(n) и O(n log n) — неплохие алгоритмы.
# O(n2), O(2n) и O(n!) — медленные алгоритмы.

# O(1), постоянное время
#
# Если вы проверяете, пуста ли книжная полка, это операция с постоянным време-
# нем. Неважно, сколько книг на полке; вы с первого взгляда определите, есть ли
# на ней книги. Их количество может изменяться, но время выполнения останется
# постоянным, потому что, если вы видите на полке хотя бы одну книгу, дальше
# можно не проверять. Значение n не влияет на скорость выполнения задачи, по-
# этому n не входит в обозначение O(1). Также постоянное время иногда записы-
# вается в виде O(c).

# O(log n), логарифмическое время
#
#
# Логарифм является операцией, обратной по отношению к возведению в степень;
# результат 24, или 2 × 2 × 2 × 2, равен 16, тогда как логарифм log2(16) (читается
# «логарифм 16 по основанию 2») равен 4. В программировании часто предполага-
# ется, что логарифм вычисляется по основанию 2, поэтому мы используем O(log n)
# вместо O(log2 n).

# O(n), линейное время
#
#
# Чтение всех книг на полке является операцией с линейным временем. Если книги
# приблизительно одинакового объема, то при удвоении количества книг на полке
# для чтения понадобится приблизительно вдвое больше времени. Время выполнения
# растет пропорционально количеству книг n.

# O(n log n), время N-Log-N
#
#
# Сортировка набора книг в алфавитном порядке является операцией со временем
# n-log-n. Этот порядок является произведением O(n) и O(log n). Можно рассматри-
# вать задачу O(n log n) как задачу O(log n), которую необходимо выполнить n раз.
# Я попробую неформально объяснить почему.
# Начните со стопки книг, которую необходимо расставить по алфавиту, и пустой
# книжной полки. Выполните последовательность действий алгоритма бинарного
# поиска, описанную в подразделе «O(log n), логарифмическое время», с. 271, чтобы
# определить место одной книги на полке. Как вы уже знаете, эта операция имеет
# порядок O(log n). Если есть n книг и упорядочение каждой книги требует log n
# итераций, упорядочение всего набора книг займет n × log n, или n log n итераций.
# При удвоении количества книг количество шагов увеличится чуть более чем вдвое,
# так что алгоритмы n log n неплохо масштабируются.

# O(n2), полиномиальное время
#
#
# Проверка наличия одинаковых книг на неупорядоченной книжной полке является
# операцией с полиномиальным временем. Если на полке 100 книг, можно начать
# с первой и сравнить ее с 99 остальными книгами, чтобы узнать, найдется ли такая
# же. Затем вы берете вторую книгу и сравниваете ее с 99 остальными. Поиск дубли-
# ката одного издания выполняется на 99 шагов (округлим до 100, то есть n в нашем
# примере). Это необходимо сделать 100 раз, по одному для каждого экземпляра.
# Таким образом, количество шагов для выявления всех дубликатов составит прибли-
# зительно n × n, или n2. (Приближение n2 верно даже в том случае, если действовать
# умнее и не повторять уже выполненные сравнения.)
# Время выполнения возрастает в квадратичной зависимости от количества книг.
# Проверка 100 книг на наличие дубликатов выполняется за 100 × 100, или 10 000 ша-
# гов. Но при удвоении числа книг потребуется 200 × 200, или 40 000 итераций: объем
# работы увеличивается в четыре раза.

# O(2n), экспоненциальное время
#
#
# Фотографирование всех возможных комбинаций книг на полке — операция с экс-
# поненциальным временем. Логика такова: каждая книга на полке может либо
# присутствовать на фотографии, либо отсутствовать. На рис. 13.1 изображены все
# возможные комбинации для n = 1, 2 или 3. Для n=1 возможны всего две фотографии:
# с книгой и без нее. Если n=2, количество фотографий увеличивается до четырех:
# обе книги на полке, обе книги не на полке, только первая книга на полке или только
# вторая книга на полке. При добавлении третьей книги объем необходимой работы
# снова удваивается: необходимо обработать каждое подмножество двух книг, ко-
# торое включает третью книгу (четыре фотографии), и каждое подмножество двух
# книг, которое не включает третью книгу (еще четыре фотографии — итого 23, или
# 8 фотографий.)

# O(n!), факториальное время
#
#
# Фотографирование книг на полке во всех возможных последовательностях — опе-
# рация с факториальным временем. Все возможные варианты упорядочения n книг
# называются перестановками. Всего существуют n! (n факториал) перестановок.
# Факториал числа равен произведению всех положительных целых чисел вплоть
# до этого числа. Например, факториал 3 равен 3 × 2 × 1, то есть 6. На рис. 13.2 пред-
# ставлены все возможные перестановки трех книг

# ***ВСЯ НЕОБХОДИМАЯ МАТЕМАТИКА ДЛЯ НОТАЦИИ*** «О-БОЛЬШОЕ»
#
#
# Если вы подзабыли алгебру, я приведу более чем достаточные математические
# обоснования для анализа «О-большое».
# Умножение. Многократное сложение: 2 × 4 = 8, так как 2 + 2 + 2 + 2 = 8.
# С переменными n + n + n равно 3 × n.
# Умножение. В алгебраической записи знак × часто опускается, так что
# 2 × n записывается в виде 2n. С числами 2 × 3 записывается в виде 2(3) или
# просто 6.
# Свойство мультипликативного тождества. При умножении числа на 1 будет
# получено то же число: 5 × 1 = 5, 42 × 1 = 42. В более общем виде n × 1 = n.
# Дистрибутивность умножения. 2 × (3 + 4) = (2 × 3) + (2 × 4). Обе части запи-
# си равны 14. В более общем виде a(b + c) = ab + ac.
# Возведение в степень. Многократное умножение: 24 = 16 (читается «2 в чет-
# вертой степени равно 16»), так как 2 × 2 × 2 × 2 = 16. Число 2 называется
# основанием, а 4 — показателем степени. С переменными n × n × n × n равно
# n4. В Python для возведения в степень используется оператор **: 2 ** 4 дает
# результат 16.
# При возведении в степень 1 результатом является основание степени: 21 = 2,
# а 99991 = 9999. В более общем виде n1 = n.
# Результат возведения в степень 0 всегда равен 1: 20 = 1, и 99990 = 1. В более
# общем виде n0 = 1.

# ***Коэффициенты***
#
#
#  Множители: в выражении 3n2 + 4n + 5 коэффициенты равны
# 3, 4 и 5. 5 тоже является коэффициентом, потому что 5 можно переписать
# в виде 5(1), а затем записать в виде 5n0
# .
# Логарифм. Операция, обратная возведению в степень. 24 = 16, а следо-
# вательно, log2(16) = 4 (читается «логарифм 16 по основанию 2 равен 4»).
# В Python для вычисления логарифма используется функция math.log():
# math.log(16, 2) дает результат 4.0.
# Вычисление «О-большое» часто требует упрощения формул за счет объеди-
# нения членов, то есть произведений чисел и переменных: в выражении 3n2 +
# + 4n + 5 членами являются 3n2, 4n и 5. Подобные члены содержат одинаковые
# переменные, возведенные в одну степень. В выражении 3n2 + 4n + 6n + 5 чле-
# ны 4n и 6n являются подобными. Выражение можно упростить и переписать
# в виде 3n2 + 10n + 5.
# Следует помнить, что поскольку n × 1 = n, выражение вида 3n2 + 5n + 4 можно
# рассматривать в виде 3n2 + 5n + 4(1). Члены этого выражения соответствуют по-
# рядкам «О-большое» O(n2), O(n) и O(1). Мы еще вернемся к этому факту, когда
# займемся исключением коэффициентов в вычислениях нотации «О-большое».
# Эта сводка пригодится нам позднее, когда вы научитесь вычислять порядок
# сложности нотации «О-большое» для фрагментов кода. Но скорее всего, по-
# сле раздела «Моментальный анализ сложности» этой главы она вам уже не
# понадобится. «О-большое» — простая концепция, которая может принести
# пользу даже без четкого следования математическим правилам.

# ***Примеры анализа*** «О-большое»
#
#
# Определим порядки «О-большое» для некоторых примеров функций. В этих при-
# мерах будет использоваться параметр books, который представляет собой список
# строк с названиями книг.
# Функция countBookPoints() вычисляет оценку на основании количества книг
# в списке. Большинство книг получает одно очко, а книги определенного автора
# получают два очка:
# def countBookPoints(books):
# points = 0 # 1 шаг
# for book in books: # n * шагов в цикле
# points += 1 # 1 шаг

# ***Порядки некоторых операций***:
#
#     - s[i] reading и s[i] = value assignment — операции O(1).
#     - s.append(value) — операция O(1).
#     - s.insert(i, value) — операция O(n). Вставка значения в последовательность
#     (особенно в начало) требует сдвига всех элементов с индексами выше i на
#     одну позицию вверх в последовательности.
#     - s.remove(value) — операция O(n). Удаление значений из последовательности
#     (особенно в начале) требует сдвига всех элементов с индексами выше i на
#     одну позицию вниз в последовательности.
#     - s.reverse() — операция O(n), потому что необходимо переставить все эле-
#     менты последовательности.
#     - s.sort() — операция O(n log n), потому что алгоритм сортировки Python
#     имеет сложность O(n log n).
#     - value in s — операция O(n), потому что необходимо проверить каждый
#     элемент.
#     - for value in s: — операция O(n).
#     - len(s) — операция O(1), потому что Python хранит количество элементов
#     в последовательности, чтобы их не приходилось заново пересчитывать при
#     каждом вызове len().
#     - m[key]reading и m[key] = value assignment — операции O(1).
#     - m.add(value) — операция O(1).
#     - value in m — операция O(1) для словарей; выполняется намного быстрее, чем
#     для последовательностей.
#     - for key in m: — операция O(n).
# l   - en(m) — операция O(1), потому что Python хранит количество элементов
#     в отображении, чтобы их не приходилось заново пересчитывать при каждом
#     вызове len()

#
